#!/usr/bin/env ruby
# credit to  ciconia
# http://snippets.dzone.com/posts/show/2265

require 'fileutils'
require File.dirname(__FILE__)+'/../vendor/gems/butterfly/lib/butterfly.rb'

module Daemon
  
  # WorkingDirectory = File.expand_path(File.dirname(__FILE__)) 
  def working_directory(dir = File.expand_path(File.dirname(__FILE__))  )
    @working_directory ||= dir
  end
  
  class Base
    def self.pid_fn
      File.join(working_directory, "#{name}.pid")
    end
    
    def self.daemonize
      Controller.daemonize(self)
    end
  end
  
  module PidFile
    def self.store(daemon, pid)
      File.open(daemon.pid_fn, 'w') {|f| f << pid}
    end
    
    def self.recall(daemon)
      IO.read(daemon.pid_fn).to_i rescue nil
    end
  end
  
  module Controller
    def self.daemonize(daemon)
      case !ARGV.empty? && ARGV[0]
      when 'start'
        start(daemon)
      when 'stop'
        stop(daemon)
      when 'restart'
        stop(daemon)
        start(daemon)
      else
        puts "Invalid command. Please specify start, stop or restart."
        exit
      end
    end

    def self.start(daemon)
      fork do
        Process.setsid
        exit if fork
        PidFile.store(daemon, Process.pid)
        Dir.chdir working_directory
        File.umask 0000
        STDIN.reopen "/dev/null"
        STDOUT.reopen "/dev/null", "a"
        STDERR.reopen STDOUT
        trap("TERM") {daemon.stop; exit}
        daemon.start
      end
    end

    def self.stop(daemon)
      if !File.file?(daemon.pid_fn)
        puts "Pid file not found. Is the daemon started?"
        exit
      end
      puts "stopping #{self.class}"
      pid = PidFile.recall(daemon)
      FileUtils.rm(daemon.pid_fn)
      pid && Process.kill("TERM", pid)
    end
  end
end


monitor_dir = ::File.join(::File.dirname(__FILE__),'..','lib/poolparty/monitors/')
require(::File.join(monitor_dir, 'stats_monitor_adaptor.rb') )

# Butterfly.register_adaptor(::File.join(monitor_dir, 'monitors/server_monitor.rb'))
# Butterfly.register_adaptor(::File.join(monitor_dir, 'server_monitor_adaptor.rb') )

class Butterfly::Server
  include Daemon
end
# puts Butterfly.constants.inspect
# Butterfly::Server.daemonize

Butterfly::Server.new(
  { :adaptor_opts => {
    :file => ::File.join(monitor_dir, 'stats_monitor_adaptor.rb')},
    :port => PoolParty::Default.butterfly_port
  }
).start!


# class ButterflyDaemon < Daemon::Base
#   def self.start
#     Butterfly::Server.new({}).start!
#   end
# end
# ButterflyDaemon.daemonize()
