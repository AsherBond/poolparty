#!/usr/bin/env ruby
$:.unshift(File.join(File.dirname(__FILE__), "..", "lib"))
# require "poolparty/lite"
# require "poolparty/core/array"
require 'poolparty'

list_type = ARGV.shift || "ip"

json_file = ARGV[0] || ENV['CLOUD_JSON_FILE'] || PoolParty::Default.properties_hash_file
raise "ERROR: no json_file given" if !json_file

cld = Cloud.load_from_json(::File.read(json_file))
conditions= {:status=>'running', :keypair=>cld.keypair_name}
inst_array = cld.remote_base.describe_instances.select_with_hash(conditions)
puts inst_array.collect{|n| n[list_type] || n[list_type.to_sym]}.join("\t")


# schema = PoolParty::Schema.new( ::File.read(json_file) )
# 
# inst_array = nil #PoolParty::Neighborhoods.load_default.instances
# 
# if !inst_array || inst_array.empty?
#   remote_base = PoolParty::Remote.module_eval( schema.options.remoter_base.camelcase )
#   instances = remote_base.send :describe_instances, schema.options.keypair_name
#   inst_array = instances.map {|inst| inst.send list_type.to_sym }.compact
#   if ['ip', 'public_id', 'internal_ip'].include? list_type
#     inst_array.delete_if{|n| !n.match(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/) }
#   end
#   print inst_array.compact.join("\t")
# else
#   print inst_array.map {|inst| inst.send list_type.to_sym }.compact.join("\t")
# end